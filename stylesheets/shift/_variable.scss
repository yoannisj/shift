// =============================================================================
// =SHIFT - VARIABLE
// =============================================================================

@import "sassy-maps";
@import "SassyLists";
@import "aleksi/general/default-to";
@import "aleksi/general/css-rule";

@import "shift/config";
@import "shift/params/expression";
@import "shift/params/handle";
@import "shift/params/parse";
@import "shift/context";
@import "shift/query";

// =is-shift-variable( $var )
// -----------------------------------------------------------------------------
/// Checks whether the given variable defines values for different media
/// contexts. A shift variable is a map with keys that each describe a media
/// context (either a shift expression or a shift handle).
///
/// @param {any} $var - The variable to test
/// @return {bool} - Wheter $var is a shift variable or not
///
/// @access public
/// @since 0.3.0
///
/// @TODO: implement memoization for performance

@function is-shift-variable($var)
{
  // only maps can be shift variables
  @if type-of($var) != 'map' {
    @return false;
  }

  @each $key, $val in $var
  {
    // if any of the keys is neither a shift expression nor a shift handle
    @if $key != 'df' and not shift-validate-expression($key)
      and not shift-validate-handle($key)
    {
      // this is not a shift variable
      @return false;
    }
  }

  // all keys are either a shift expression or a shift handle
  @return true;
}

// =shift-parse-keys( $var )
// -----------------------------------------------------------------------------
/// Parses each key in given shift variable, and returns a map pairing each key
/// with the parsed features it defines.
///
/// @param $var - the shift variable to parse
///
/// @throw Error - if $var is not a valid shift variable
/// @return {map} - the map of keys -> parsed features
///
/// @api public
/// @since 0.3.0
///
/// @todo: implement memoization for increased performance

@function shift-parse-keys( $var )
{
  // this only works on valid shift variables
  @if not is-shift-variable($var) {
    @return throw-error('shift-parse-keys(): $var must be a valid shift variable â€“ was #{inspect($var)}.');
  }

  $params: ();
  @each $key, $val in $var {
    $params: map-set($params, $key, shift-parse($key));
  }

  @return $params;
}

// =shift-stagger-variable( $var )
// -----------------------------------------------------------------------------

@function shift-stagger-variable( $var )
{
  $params: shift-parse-keys($var);

  $widths: ();
  $heights: ();

  @each $key, $val in $var
  {
    $prm: map-get($params, $key);
    $min-w: map-get($prm, 'min-width');
    $max-w: map-get($prm, 'min-height');

    @if not index($widths, $min-w) { $widths: append($widths, $min-w); }
    @if not index($widths, $max-w) { $widths: append($widths, $max-w); }
    @if not index($heights, $min-h) { $heights: append($heights, $min-h); }
    @if not index($heights, $max-h) { $heights: append($heights, $max-h); }
  }

  $widths: sl-sort($widths);
  $heights: sl-sort($heights);

  $keys: ();

}

// =shift-scope-variable( $var[, $context ])
// -----------------------------------------------------------------------------
/// Limits a shift-variable to the scope of given context. Keys that are out of
/// scope are removed, and keys overlapping context scope are limited to fit in.
///
/// @param $var - the shift variable to re-scope
/// @param $context [shift-context()] - the context features to use as scope
///
/// @throw Error - if $var is not a valid shift variable
/// @return {map} - the map of keys -> parsed features
///
/// @api public
/// @since 0.3.0
///
/// @todo: implement memoization for increased performance

@function shift-scope-variable( $var, $context: null )
{
  // default to current context
  $context: default-to($context, shift-context());

  // get context's scoping features
  $media: default-to(map-get($context, 'media'), $shift-media-type);
  $min-w: map-get($context, 'min-width');
  $max-w: map-get($context, 'max-width');
  $min-h: map-get($context, 'min-height');
  $max-h: map-get($context, 'max-height');

  // initialize scoped copy of variable
  $scoped: ();

  // if regular key was given
  @if not is-shift-variable($var) {
    // return a shift variable with scope as only key
    $scoped-key: shift-expression($context);
    @return map-set($scoped, $scoped-key, $var);
  }

  // get shift params for each key
  $params: shift-parse-keys($var);

  @each $key, $val in $var
  {
    $prm: map-get($params, $key);
    $prm-media: default-to(map-get($prm, 'media-type'), $shift-media-type);
    $prm-min-w: map-get($prm, 'min-width');
    $prm-max-w: map-get($prm, 'max-width');
    $prm-min-h: map-get($prm, 'min-height');
    $prm-max-h: map-get($prm, 'max-height');

    // if key is out of context's scope
    @if $media != $prm-media
      or ($prm-min-w != null and $prm-min-w >= default-to($max-w, 999999))
      or ($prm-max-w != null and $prm-max-w < default-to($min-w, 0))
      or ($prm-min-h != null and $prm-min-h >= default-to($max-h, 999999))
      or ($prm-max-h != null and $prm-max-h < default-to($min-h, 0))
    {
      // don't add this value to scoped copy of variable
    }

    @else
    {
      // limit keys that overlap with context's scope
      @if default-to($prm-min-w, 0) < default-to($min-w, 0) {
        $prm: map-set($prm, 'min-width', $min-w);
      }

      @if default-to($prm-max-w, 999999) > default-to($max-w, 999999) {
        $prm: map-set($prm, 'max-width', $max-w);
      }

      @if default-to($prm-min-h, 0) < default-to($min-h, 0) {
        $prm: map-set($prm, 'min-height', $min-h);
      }

      @if default-to($prm-max-h, 999999) > default-to($max-h, 999999) {
        $prm: map-set($prm, 'max-height', $max-h);
      }

      // add value to scoped copy of variable
      $scoped-key: shift-expression($prm);
      $scoped: map-set($scoped, $scoped-key, $val);
    }
  }

  // return scoped copy of variable
  @return $scoped;
}

// =shift-value( $var[, $context ])
// -----------------------------------------------------------------------------
/// @todo: implement memoization for increased performance

@function shift-value( $var, $context: null )
{
  // return regular variables' value
  @if not is-shift-variable($var) {
    @return $var;
  }

  // default to current context
  $context: default-to($context, shift-context());

  // scope variable to context to remove irrelevant values
  $res: shift-scope-variable($var, $context);

  // return null if no value corresponded
  @if $res-ln == 0 {
    @return null;
  }

  // return a single value if only one key corresponded
  @else if $res-ln == 1 {
    @return map-get($res, nth(map-keys($res), 1));
  }

  // return all values that correspond
  @return $res;
}

// =shift-align-variables( $vars )
// -----------------------------------------------------------------------------

@function shift-align-keys( $vars )
{
  $first: shift-scope-variable(nth($vars, 1));
  $keys: map-keys($first);

  @debug $first;

  $num-vars: length($vars);

  @for $i from 2 through $num-vars
  {
    $var: shift-scope-variable(nth($vars, $i));

    @for $i from 1 through length($keys)
    {
      $key: nth($keys, $i);
      $prm: shift-parse($key);
      $key-val: shift-scope-variable($var, $prm);

      @if length($key-val) > 1
      {
        // replace the current key, with those from returned value
        $keys: sl-remove-nth($keys, $i);

        $val-keys: map-keys($key-val);
        $j: length($val-keys);

        @while $j > 0
        {
          $k: nth($val-keys, $j);
          $keys: sl-insert-nth($keys, $i, $k);
          $j: $j - 1;
        }
      }
    }
  }

  @return $keys;
}

// =shift-align-variables( $vars )
// -----------------------------------------------------------------------------

@function shift-align-variables( $vars )
{
  $widths: ();
  $heights: ();

  // collect unique values for length features
  @each $var in $vars
  {
    $params: shift-parse-keys($var);

    @each $key, $prm in $params
    {
      $min-w: map-get($prm, 'min-width');
      $max-w: map-get($prm, 'min-width');
      $min-h: map-get($prm, 'min-height');
      $max-h: map-get($prm, 'min-height');

      @if $min-w != null and not index($widths, $min-w) {
        $widths: append($widths, $min-w);
      }

      @if $max-w != null and not index($widths, $max-w) {
        $widths: append($widths, $max-w);
      }

      @if $min-h != null and not index($widths, $min-h) {
        $heights: append($widths, $min-h);
      }

      @if $max-h != null and not index($widths, $max-h) {
        $heights: append($widths, $max-h);
      }
    }
  }

  // sort collected length values in ascending order
  $widths: sl-sort($widths);
  $heights: sl-sort($heights);

  // create list of keys for all possible intervals...
  $keys: ();

  // add 'max-' length only at start
  $keys: append($keys, shift-expression('max-width', nth($widths, 1)));

  @for $w from 1 through $w-total
  {
    $min-w: if($w == 1, null, nth($widths, $w));
    $max-w: if($w == $w-total, null, nth($widths, $w + 1));

    @for $h from 1 through $h-total
    {
      $min-h: if($h == 1, null, nth($heights, $h));
      $max-h: if($h == $h-total, null, nth($height, $h + 1));

      $key: shift-expression((
        'min-width': $min-w,
        'max-width': $max-w,
        'min-height': $min-h,
        'max-height': $max-h
      ));
    }

    @if $i == 1 {
      $prm: ('max-width': $w);
    }

    @else if $i == $num-widths {
      $prm: ('max-width': $w);
    }

    @else {
      $prm: ('min-width': $w, 'max-width': $next-w);
    }

    $keys: append($keys, shift-expression($prm));
  }

  // add 'min-' length only at end

  @return $keys;
}

// =Mixins
// =============================================================================

// =shift-value( $prop, $var[, $important ])
// -----------------------------------------------------------------------------
/// Outputs styles for a given css property and corresponding values from a
/// shift variable, scoped into current context and wrapped in media-queries.
///
/// @param {string} $prop - The css property to output
/// @param {map} $var - The shift variable to use as value
/// @param {bool} $important - Whether to append the `!important` flag or not
///
/// @example scss
///   Example Code
///
/// @access public
/// @since 0.3.0

@mixin shift-value($prop, $var, $important: false)
{
  @if not is-shift-variable($var) {
    #{$prop}: css-value($var, $important);
  }

  // scope variable in current context
  $var: shift-scope-variable($var);

  @each $key, $val in $var
  {
    @at-root (without: media)
    {
      & {
        @include shift-query($key) {
          #{$prop}: css-value($val, $important);
        }
      }
    }
  }
}